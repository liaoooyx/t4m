plugins {
    id "org.sonarqube" version "2.7"
}

allprojects {

    version '1.0-SNAPSHOT'
    group 'com.t4m'

    task cleanBuildDir(type: Delete) {
        delete "${projectDir}/build"
        delete "${projectDir}/out"
    }

}

subprojects {
    apply plugin: 'java'
    apply plugin: 'idea'
    apply plugin: 'jacoco'

    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11

    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
    }
    tasks.withType(Javadoc) {
        options.encoding = 'UTF-8'
        title = project.name + ' ' + project.version
    }

    idea {
        module {
            inheritOutputDirs = true
        }
    }

    repositories {
        mavenLocal()
        mavenCentral()
    }

    /*Config for Junit test*/
    test {
        useJUnitPlatform()
        testLogging {
            events "passed", "skipped", "failed"
            showStandardStreams = true
        }
        finalizedBy jacocoTestReport // report is always generated after tests run
    }

    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.2'
        testImplementation 'org.junit.jupiter:junit-jupiter-params:5.6.2'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.6.2'

        compile 'org.slf4j:slf4j-api:1.7.30'
        compile 'ch.qos.logback:logback-core:1.2.3'
        compile 'ch.qos.logback:logback-classic:1.2.3'
    }

    sonarqube {
        properties {
            property "sonar.coverage.jacoco.xmlReportPaths", jacocoTestReport.reports.xml.destination
        }
    }

    jacocoTestReport {
        dependsOn test // tests are required to run before generating the report
        reports {
            html.enabled = true
            xml.enabled = true
            csv.enabled = false
        }
    }
}

task aggregatedJavadocs(type: Javadoc, description: 'Generate javadocs from all child projects as if it was a single project', group: 'Documentation') {
    destinationDir = file("$buildDir/docs/javadoc")
    title = "$project.name $version API"
    options.author true
    options.links = ['http://docs.oracle.com/javase/11/docs/api/','http://docs.spring.io/spring/docs/current/javadoc-api/']
    options.addStringOption 'Xdoclint:none', '-quiet'

    subprojects.each { proj ->
        proj.tasks.withType(Javadoc).each { javadocTask ->
            source += javadocTask.source
            classpath += javadocTask.classpath
            excludes += javadocTask.excludes
            includes += javadocTask.includes
        }
    }
}

task buildJarToBin(type: Copy) {
    dependsOn 't4m-web:test'
    dependsOn 't4m-web:build'
    File binDir = new File("${project.rootDir}/bin")
    if (binDir.exists()) {
        binDir.listFiles().each { file -> file.delete() }
        binDir.delete()
    }
    File webProp = new File("${project.rootDir}/conf/web.properties")
    if (webProp.exists()) {
        webProp.delete()
    }
    new File("${project.rootDir}/conf/web.properties") << "CURRENT_PROJECT_IDENTIFIER=t4m\\#1598965273568"
    from 't4m-web/build/libs'
    into 'bin/'
}


// ./gradlew -q findDependencyPath > deps.txt
task findDependencyPath {
    project.allprojects.each { module ->
        tasks.create("findDependencyPath_${module.name}", {
            doLast {
                Set<String> depsSet = new HashSet<>()
                module.configurations.each { conf ->
                    if (conf.isCanBeResolved()) {
                        conf.getResolvedConfiguration().getResolvedArtifacts().each { artifact ->
                            def jarPath = artifact.getFile().getAbsolutePath()
                            if (jarPath != null && "" != jarPath) {
                                depsSet.add(jarPath)
                            }
                        }
                    }
                }
                String depsString = depsSet.stream().map { e -> e.concat(File.pathSeparator) }
                        .reduce { a, b -> a.concat(b) }.orElse("")
                new File(module.name + ".deps") << depsString
            }
        })
        findDependencyPath.dependsOn("findDependencyPath_${module.name}")
    }
    doLast {
        Set<String> depsSet = new HashSet<>()
        project.allprojects.each { module ->
            def moduleName = module.name
            if (file(moduleName + ".deps").exists()) {
                file(moduleName + ".deps").eachLine { line ->
                    line.split(File.pathSeparator).each { jarPath -> depsSet.add(jarPath) }
                }
                file(moduleName + ".deps").delete()
            }
        }
        String depsString = depsSet.stream().map { e -> e.concat(File.pathSeparator) }
                .reduce { a, b -> a.concat(b) }.orElse("")
        depsString = depsString.substring(0, depsString.length() - 1)
        println depsString
    }
}